
gpio_displat7seg.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000010  00800100  00000a52  00000ae6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000a52  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000007  00800110  00800110  00000af6  2**0
                  ALLOC
  3 .stab         00001d70  00000000  00000000  00000af8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000015ff  00000000  00000000  00002868  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00003e67  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00003e78  2**2
                  CONTENTS, READONLY
  7 .debug_aranges 00000060  00000000  00000000  00003eb8  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   00000666  00000000  00000000  00003f18  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 000005de  00000000  00000000  0000457e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   0000019a  00000000  00000000  00004b5c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000266  00000000  00000000  00004cf6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 3c 00 	jmp	0x78	; 0x78 <__ctors_end>
   4:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
   8:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
   c:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  10:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  14:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  18:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  1c:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  20:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  24:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  28:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  2c:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  30:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  34:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  38:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  3c:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  40:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  44:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  48:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  4c:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  50:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  54:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  58:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  5c:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>
  60:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__vector_24>
  64:	0c 94 59 00 	jmp	0xb2	; 0xb2 <__bad_interrupt>

00000068 <convTable>:
  68:	40 79 24 30 19 12 02 78 00 18 08 03 46 21 06 0e     @y$0...x....F!..

00000078 <__ctors_end>:
  78:	11 24       	eor	r1, r1
  7a:	1f be       	out	0x3f, r1	; 63
  7c:	cf ef       	ldi	r28, 0xFF	; 255
  7e:	d8 e0       	ldi	r29, 0x08	; 8
  80:	de bf       	out	0x3e, r29	; 62
  82:	cd bf       	out	0x3d, r28	; 61

00000084 <__do_copy_data>:
  84:	11 e0       	ldi	r17, 0x01	; 1
  86:	a0 e0       	ldi	r26, 0x00	; 0
  88:	b1 e0       	ldi	r27, 0x01	; 1
  8a:	e2 e5       	ldi	r30, 0x52	; 82
  8c:	fa e0       	ldi	r31, 0x0A	; 10
  8e:	02 c0       	rjmp	.+4      	; 0x94 <__do_copy_data+0x10>
  90:	05 90       	lpm	r0, Z+
  92:	0d 92       	st	X+, r0
  94:	a0 31       	cpi	r26, 0x10	; 16
  96:	b1 07       	cpc	r27, r17
  98:	d9 f7       	brne	.-10     	; 0x90 <__do_copy_data+0xc>

0000009a <__do_clear_bss>:
  9a:	21 e0       	ldi	r18, 0x01	; 1
  9c:	a0 e1       	ldi	r26, 0x10	; 16
  9e:	b1 e0       	ldi	r27, 0x01	; 1
  a0:	01 c0       	rjmp	.+2      	; 0xa4 <.do_clear_bss_start>

000000a2 <.do_clear_bss_loop>:
  a2:	1d 92       	st	X+, r1

000000a4 <.do_clear_bss_start>:
  a4:	a7 31       	cpi	r26, 0x17	; 23
  a6:	b2 07       	cpc	r27, r18
  a8:	e1 f7       	brne	.-8      	; 0xa2 <.do_clear_bss_loop>
  aa:	0e 94 c9 02 	call	0x592	; 0x592 <main>
  ae:	0c 94 27 05 	jmp	0xa4e	; 0xa4e <_exit>

000000b2 <__bad_interrupt>:
  b2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000b6 <SPI_MasterInit>:
#define MISO PB4
#define SCK PB5

/*\ Inicialização do SPÌ */
void SPI_MasterInit(void)
{
  b6:	cf 93       	push	r28
  b8:	df 93       	push	r29
  ba:	cd b7       	in	r28, 0x3d	; 61
  bc:	de b7       	in	r29, 0x3e	; 62
	/* Configura direção das portas */
	GPIO_B->DDR = (1 << SS) | (1 << MOSI) | (1 << SCK);
  be:	83 e2       	ldi	r24, 0x23	; 35
  c0:	90 e0       	ldi	r25, 0x00	; 0
  c2:	2c e2       	ldi	r18, 0x2C	; 44
  c4:	fc 01       	movw	r30, r24
  c6:	21 83       	std	Z+1, r18	; 0x01

	/* Ativa SPI em modo mestre
	 * clock = F_CPU / 16  */
	SPI->SP_CR.MASK = SET(SPE) | SET(MSTR) | SET(SPR0)  | SET(DORD);
  c8:	8c e4       	ldi	r24, 0x4C	; 76
  ca:	90 e0       	ldi	r25, 0x00	; 0
  cc:	21 e7       	ldi	r18, 0x71	; 113
  ce:	fc 01       	movw	r30, r24
  d0:	20 83       	st	Z, r18
	/* Diretamente:
	SPCR = (1 << SPE)|(1 << MSTR)|(1 << SPR0); */
}
  d2:	00 00       	nop
  d4:	df 91       	pop	r29
  d6:	cf 91       	pop	r28
  d8:	08 95       	ret

000000da <SPI_Transmit>:

uint8_t SPI_Transmit(uint8_t byte){
  da:	cf 93       	push	r28
  dc:	df 93       	push	r29
  de:	0f 92       	push	r0
  e0:	cd b7       	in	r28, 0x3d	; 61
  e2:	de b7       	in	r29, 0x3e	; 62
  e4:	89 83       	std	Y+1, r24	; 0x01

	/* Configura dado no registrado de hardware */
	//SPI->SP_DR = byte;
	/* Diretamente: */
	SPDR = byte;
  e6:	8e e4       	ldi	r24, 0x4E	; 78
  e8:	90 e0       	ldi	r25, 0x00	; 0
  ea:	29 81       	ldd	r18, Y+1	; 0x01
  ec:	fc 01       	movw	r30, r24
  ee:	20 83       	st	Z, r18

	/* Aguarada transmissão */
	while (!SPI->SP_SR.SP_IF);
  f0:	00 00       	nop
  f2:	8c e4       	ldi	r24, 0x4C	; 76
  f4:	90 e0       	ldi	r25, 0x00	; 0
  f6:	fc 01       	movw	r30, r24
  f8:	81 81       	ldd	r24, Z+1	; 0x01
  fa:	87 fb       	bst	r24, 7
  fc:	88 27       	eor	r24, r24
  fe:	80 f9       	bld	r24, 0
 100:	88 23       	and	r24, r24
 102:	b9 f3       	breq	.-18     	; 0xf2 <SPI_Transmit+0x18>
	/* Diretamente: */
	//while(!(SPSR & (1<<SPIF)));

	/* retorna se algum dado for lido */
	return SPI->SP_DR;
 104:	8c e4       	ldi	r24, 0x4C	; 76
 106:	90 e0       	ldi	r25, 0x00	; 0
 108:	fc 01       	movw	r30, r24
 10a:	82 81       	ldd	r24, Z+2	; 0x02
}
 10c:	0f 90       	pop	r0
 10e:	df 91       	pop	r29
 110:	cf 91       	pop	r28
 112:	08 95       	ret

00000114 <SPI_SlaveReceive>:

uint8_t SPI_SlaveReceive(uint8_t byte)
{
 114:	cf 93       	push	r28
 116:	df 93       	push	r29
 118:	0f 92       	push	r0
 11a:	cd b7       	in	r28, 0x3d	; 61
 11c:	de b7       	in	r29, 0x3e	; 62
 11e:	89 83       	std	Y+1, r24	; 0x01
	// Uma recepção de SPI deve ativar o clock
	// logo, enviamos outro dado ou qualquer coisa
	return SPI_Transmit(byte);
 120:	89 81       	ldd	r24, Y+1	; 0x01
 122:	0e 94 6d 00 	call	0xda	; 0xda <SPI_Transmit>
}
 126:	0f 90       	pop	r0
 128:	df 91       	pop	r29
 12a:	cf 91       	pop	r28
 12c:	08 95       	ret

0000012e <TWI_Master_Initialise>:
/****************************************************************************
Call this function to set up the TWI master to its initial standby state.
Remember to enable interrupts from the main application after initializing the TWI.
****************************************************************************/
void TWI_Master_Initialise(void)
{
 12e:	cf 93       	push	r28
 130:	df 93       	push	r29
 132:	cd b7       	in	r28, 0x3d	; 61
 134:	de b7       	in	r29, 0x3e	; 62
  TWBR = TWI_TWBR;                                  // Set bit rate register (Baud rate). Defined in header file.Driver presumes prescaler to be 00.                                
 136:	88 eb       	ldi	r24, 0xB8	; 184
 138:	90 e0       	ldi	r25, 0x00	; 0
 13a:	24 e8       	ldi	r18, 0x84	; 132
 13c:	fc 01       	movw	r30, r24
 13e:	20 83       	st	Z, r18
  TWDR = 0xFF;                                      // Default content = SDA released.
 140:	8b eb       	ldi	r24, 0xBB	; 187
 142:	90 e0       	ldi	r25, 0x00	; 0
 144:	2f ef       	ldi	r18, 0xFF	; 255
 146:	fc 01       	movw	r30, r24
 148:	20 83       	st	Z, r18
  TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins.
 14a:	8c eb       	ldi	r24, 0xBC	; 188
 14c:	90 e0       	ldi	r25, 0x00	; 0
 14e:	24 e0       	ldi	r18, 0x04	; 4
 150:	fc 01       	movw	r30, r24
 152:	20 83       	st	Z, r18
         (0<<TWIE)|(0<<TWINT)|                      // Disable Interrupt.
         (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests.
         (0<<TWWC);                                 //
}    
 154:	00 00       	nop
 156:	df 91       	pop	r29
 158:	cf 91       	pop	r28
 15a:	08 95       	ret

0000015c <TWI_Transceiver_Busy>:
    
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
 15c:	cf 93       	push	r28
 15e:	df 93       	push	r29
 160:	cd b7       	in	r28, 0x3d	; 61
 162:	de b7       	in	r29, 0x3e	; 62
  return ( TWCR & (1<<TWIE) );                  // IF TWI Interrupt is enabled then the Transceiver is busy
 164:	8c eb       	ldi	r24, 0xBC	; 188
 166:	90 e0       	ldi	r25, 0x00	; 0
 168:	fc 01       	movw	r30, r24
 16a:	80 81       	ld	r24, Z
 16c:	81 70       	andi	r24, 0x01	; 1
}
 16e:	df 91       	pop	r29
 170:	cf 91       	pop	r28
 172:	08 95       	ret

00000174 <TWI_Get_State_Info>:
Call this function to fetch the state information of the previous operation. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation. If there was an error, then the function 
will return the TWI State code. 
****************************************************************************/
unsigned char TWI_Get_State_Info( void )
{
 174:	cf 93       	push	r28
 176:	df 93       	push	r29
 178:	cd b7       	in	r28, 0x3d	; 61
 17a:	de b7       	in	r29, 0x3e	; 62
  while ( TWI_Transceiver_Busy() );             // Wait until TWI has completed the transmission.
 17c:	00 00       	nop
 17e:	0e 94 ae 00 	call	0x15c	; 0x15c <TWI_Transceiver_Busy>
 182:	88 23       	and	r24, r24
 184:	e1 f7       	brne	.-8      	; 0x17e <TWI_Get_State_Info+0xa>
  return ( TWI_state );                         // Return error state.
 186:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
}
 18a:	df 91       	pop	r29
 18c:	cf 91       	pop	r28
 18e:	08 95       	ret

00000190 <TWI_Start_Transceiver_With_Data>:
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
{
 190:	cf 93       	push	r28
 192:	df 93       	push	r29
 194:	00 d0       	rcall	.+0      	; 0x196 <TWI_Start_Transceiver_With_Data+0x6>
 196:	00 d0       	rcall	.+0      	; 0x198 <TWI_Start_Transceiver_With_Data+0x8>
 198:	cd b7       	in	r28, 0x3d	; 61
 19a:	de b7       	in	r29, 0x3e	; 62
 19c:	9b 83       	std	Y+3, r25	; 0x03
 19e:	8a 83       	std	Y+2, r24	; 0x02
 1a0:	6c 83       	std	Y+4, r22	; 0x04
  unsigned char temp;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
 1a2:	00 00       	nop
 1a4:	0e 94 ae 00 	call	0x15c	; 0x15c <TWI_Transceiver_Busy>
 1a8:	88 23       	and	r24, r24
 1aa:	e1 f7       	brne	.-8      	; 0x1a4 <TWI_Start_Transceiver_With_Data+0x14>

  TWI_msgSize = msgSize;                        // Number of data to transmit.
 1ac:	8c 81       	ldd	r24, Y+4	; 0x04
 1ae:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <TWI_msgSize>
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
 1b2:	8a 81       	ldd	r24, Y+2	; 0x02
 1b4:	9b 81       	ldd	r25, Y+3	; 0x03
 1b6:	fc 01       	movw	r30, r24
 1b8:	80 81       	ld	r24, Z
 1ba:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <__data_end>
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
 1be:	8a 81       	ldd	r24, Y+2	; 0x02
 1c0:	9b 81       	ldd	r25, Y+3	; 0x03
 1c2:	fc 01       	movw	r30, r24
 1c4:	80 81       	ld	r24, Z
 1c6:	88 2f       	mov	r24, r24
 1c8:	90 e0       	ldi	r25, 0x00	; 0
 1ca:	81 70       	andi	r24, 0x01	; 1
 1cc:	99 27       	eor	r25, r25
 1ce:	89 2b       	or	r24, r25
 1d0:	d1 f4       	brne	.+52     	; 0x206 <TWI_Start_Transceiver_With_Data+0x76>
  {
    for ( temp = 1; temp < msgSize; temp++ )
 1d2:	81 e0       	ldi	r24, 0x01	; 1
 1d4:	89 83       	std	Y+1, r24	; 0x01
 1d6:	13 c0       	rjmp	.+38     	; 0x1fe <TWI_Start_Transceiver_With_Data+0x6e>
      TWI_buf[ temp ] = msg[ temp ];
 1d8:	89 81       	ldd	r24, Y+1	; 0x01
 1da:	88 2f       	mov	r24, r24
 1dc:	90 e0       	ldi	r25, 0x00	; 0
 1de:	2a 81       	ldd	r18, Y+2	; 0x02
 1e0:	3b 81       	ldd	r19, Y+3	; 0x03
 1e2:	28 0f       	add	r18, r24
 1e4:	39 1f       	adc	r19, r25
 1e6:	89 81       	ldd	r24, Y+1	; 0x01
 1e8:	88 2f       	mov	r24, r24
 1ea:	90 e0       	ldi	r25, 0x00	; 0
 1ec:	f9 01       	movw	r30, r18
 1ee:	20 81       	ld	r18, Z
 1f0:	80 5f       	subi	r24, 0xF0	; 240
 1f2:	9e 4f       	sbci	r25, 0xFE	; 254
 1f4:	fc 01       	movw	r30, r24
 1f6:	20 83       	st	Z, r18
    for ( temp = 1; temp < msgSize; temp++ )
 1f8:	89 81       	ldd	r24, Y+1	; 0x01
 1fa:	8f 5f       	subi	r24, 0xFF	; 255
 1fc:	89 83       	std	Y+1, r24	; 0x01
 1fe:	99 81       	ldd	r25, Y+1	; 0x01
 200:	8c 81       	ldd	r24, Y+4	; 0x04
 202:	98 17       	cp	r25, r24
 204:	48 f3       	brcs	.-46     	; 0x1d8 <TWI_Start_Transceiver_With_Data+0x48>
  }
  TWI_statusReg.all = 0;      
 206:	10 92 15 01 	sts	0x0115, r1	; 0x800115 <TWI_statusReg>
  TWI_state         = TWI_NO_STATE ;
 20a:	88 ef       	ldi	r24, 0xF8	; 248
 20c:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
 210:	8c eb       	ldi	r24, 0xBC	; 188
 212:	90 e0       	ldi	r25, 0x00	; 0
 214:	25 ea       	ldi	r18, 0xA5	; 165
 216:	fc 01       	movw	r30, r24
 218:	20 83       	st	Z, r18
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interrupt and clear the flag.
         (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
         (0<<TWWC);
}
 21a:	00 00       	nop
 21c:	0f 90       	pop	r0
 21e:	0f 90       	pop	r0
 220:	0f 90       	pop	r0
 222:	0f 90       	pop	r0
 224:	df 91       	pop	r29
 226:	cf 91       	pop	r28
 228:	08 95       	ret

0000022a <TWI_Start_Transceiver>:
Call this function to resend the last message. The driver will reuse the data previously put in the transceiver buffers.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver( void )
{
 22a:	cf 93       	push	r28
 22c:	df 93       	push	r29
 22e:	cd b7       	in	r28, 0x3d	; 61
 230:	de b7       	in	r29, 0x3e	; 62
  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
 232:	00 00       	nop
 234:	0e 94 ae 00 	call	0x15c	; 0x15c <TWI_Transceiver_Busy>
 238:	88 23       	and	r24, r24
 23a:	e1 f7       	brne	.-8      	; 0x234 <TWI_Start_Transceiver+0xa>
  TWI_statusReg.all = 0;      
 23c:	10 92 15 01 	sts	0x0115, r1	; 0x800115 <TWI_statusReg>
  TWI_state         = TWI_NO_STATE ;
 240:	88 ef       	ldi	r24, 0xF8	; 248
 242:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
 246:	8c eb       	ldi	r24, 0xBC	; 188
 248:	90 e0       	ldi	r25, 0x00	; 0
 24a:	25 ea       	ldi	r18, 0xA5	; 165
 24c:	fc 01       	movw	r30, r24
 24e:	20 83       	st	Z, r18
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interrupt and clear the flag.
         (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
         (0<<TWWC);                             //
}
 250:	00 00       	nop
 252:	df 91       	pop	r29
 254:	cf 91       	pop	r28
 256:	08 95       	ret

00000258 <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
 258:	cf 93       	push	r28
 25a:	df 93       	push	r29
 25c:	00 d0       	rcall	.+0      	; 0x25e <TWI_Get_Data_From_Transceiver+0x6>
 25e:	00 d0       	rcall	.+0      	; 0x260 <TWI_Get_Data_From_Transceiver+0x8>
 260:	cd b7       	in	r28, 0x3d	; 61
 262:	de b7       	in	r29, 0x3e	; 62
 264:	9b 83       	std	Y+3, r25	; 0x03
 266:	8a 83       	std	Y+2, r24	; 0x02
 268:	6c 83       	std	Y+4, r22	; 0x04
  unsigned char i;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
 26a:	00 00       	nop
 26c:	0e 94 ae 00 	call	0x15c	; 0x15c <TWI_Transceiver_Busy>
 270:	88 23       	and	r24, r24
 272:	e1 f7       	brne	.-8      	; 0x26c <TWI_Get_Data_From_Transceiver+0x14>

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
 274:	80 91 15 01 	lds	r24, 0x0115	; 0x800115 <TWI_statusReg>
 278:	81 70       	andi	r24, 0x01	; 1
 27a:	88 23       	and	r24, r24
 27c:	c9 f0       	breq	.+50     	; 0x2b0 <TWI_Get_Data_From_Transceiver+0x58>
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
 27e:	19 82       	std	Y+1, r1	; 0x01
 280:	13 c0       	rjmp	.+38     	; 0x2a8 <TWI_Get_Data_From_Transceiver+0x50>
    {
      msg[ i ] = TWI_buf[ i ];
 282:	89 81       	ldd	r24, Y+1	; 0x01
 284:	28 2f       	mov	r18, r24
 286:	30 e0       	ldi	r19, 0x00	; 0
 288:	89 81       	ldd	r24, Y+1	; 0x01
 28a:	88 2f       	mov	r24, r24
 28c:	90 e0       	ldi	r25, 0x00	; 0
 28e:	4a 81       	ldd	r20, Y+2	; 0x02
 290:	5b 81       	ldd	r21, Y+3	; 0x03
 292:	84 0f       	add	r24, r20
 294:	95 1f       	adc	r25, r21
 296:	20 5f       	subi	r18, 0xF0	; 240
 298:	3e 4f       	sbci	r19, 0xFE	; 254
 29a:	f9 01       	movw	r30, r18
 29c:	20 81       	ld	r18, Z
 29e:	fc 01       	movw	r30, r24
 2a0:	20 83       	st	Z, r18
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
 2a2:	89 81       	ldd	r24, Y+1	; 0x01
 2a4:	8f 5f       	subi	r24, 0xFF	; 255
 2a6:	89 83       	std	Y+1, r24	; 0x01
 2a8:	99 81       	ldd	r25, Y+1	; 0x01
 2aa:	8c 81       	ldd	r24, Y+4	; 0x04
 2ac:	98 17       	cp	r25, r24
 2ae:	48 f3       	brcs	.-46     	; 0x282 <TWI_Get_Data_From_Transceiver+0x2a>
    }
  }
  return( TWI_statusReg.lastTransOK );                                   
 2b0:	80 91 15 01 	lds	r24, 0x0115	; 0x800115 <TWI_statusReg>
 2b4:	81 70       	andi	r24, 0x01	; 1
}
 2b6:	0f 90       	pop	r0
 2b8:	0f 90       	pop	r0
 2ba:	0f 90       	pop	r0
 2bc:	0f 90       	pop	r0
 2be:	df 91       	pop	r29
 2c0:	cf 91       	pop	r28
 2c2:	08 95       	ret

000002c4 <__vector_24>:
This function is the Interrupt Service Routine (ISR), and called when the TWI interrupt is triggered;
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR(TWI_vect)
{
 2c4:	1f 92       	push	r1
 2c6:	0f 92       	push	r0
 2c8:	0f b6       	in	r0, 0x3f	; 63
 2ca:	0f 92       	push	r0
 2cc:	11 24       	eor	r1, r1
 2ce:	2f 93       	push	r18
 2d0:	3f 93       	push	r19
 2d2:	8f 93       	push	r24
 2d4:	9f 93       	push	r25
 2d6:	ef 93       	push	r30
 2d8:	ff 93       	push	r31
 2da:	cf 93       	push	r28
 2dc:	df 93       	push	r29
 2de:	cd b7       	in	r28, 0x3d	; 61
 2e0:	de b7       	in	r29, 0x3e	; 62
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
 2e2:	89 eb       	ldi	r24, 0xB9	; 185
 2e4:	90 e0       	ldi	r25, 0x00	; 0
 2e6:	fc 01       	movw	r30, r24
 2e8:	80 81       	ld	r24, Z
 2ea:	88 2f       	mov	r24, r24
 2ec:	90 e0       	ldi	r25, 0x00	; 0
 2ee:	88 35       	cpi	r24, 0x58	; 88
 2f0:	91 05       	cpc	r25, r1
 2f2:	09 f4       	brne	.+2      	; 0x2f6 <__vector_24+0x32>
 2f4:	81 c0       	rjmp	.+258    	; 0x3f8 <__vector_24+0x134>
 2f6:	89 35       	cpi	r24, 0x59	; 89
 2f8:	91 05       	cpc	r25, r1
 2fa:	0c f0       	brlt	.+2      	; 0x2fe <__vector_24+0x3a>
 2fc:	9a c0       	rjmp	.+308    	; 0x432 <__FUSE_REGION_LENGTH__+0x32>
 2fe:	80 35       	cpi	r24, 0x50	; 80
 300:	91 05       	cpc	r25, r1
 302:	09 f4       	brne	.+2      	; 0x306 <__vector_24+0x42>
 304:	51 c0       	rjmp	.+162    	; 0x3a8 <__vector_24+0xe4>
 306:	81 35       	cpi	r24, 0x51	; 81
 308:	91 05       	cpc	r25, r1
 30a:	0c f0       	brlt	.+2      	; 0x30e <__vector_24+0x4a>
 30c:	92 c0       	rjmp	.+292    	; 0x432 <__FUSE_REGION_LENGTH__+0x32>
 30e:	80 34       	cpi	r24, 0x40	; 64
 310:	91 05       	cpc	r25, r1
 312:	09 f4       	brne	.+2      	; 0x316 <__vector_24+0x52>
 314:	59 c0       	rjmp	.+178    	; 0x3c8 <__vector_24+0x104>
 316:	81 34       	cpi	r24, 0x41	; 65
 318:	91 05       	cpc	r25, r1
 31a:	0c f0       	brlt	.+2      	; 0x31e <__vector_24+0x5a>
 31c:	8a c0       	rjmp	.+276    	; 0x432 <__FUSE_REGION_LENGTH__+0x32>
 31e:	88 33       	cpi	r24, 0x38	; 56
 320:	91 05       	cpc	r25, r1
 322:	09 f4       	brne	.+2      	; 0x326 <__vector_24+0x62>
 324:	80 c0       	rjmp	.+256    	; 0x426 <__FUSE_REGION_LENGTH__+0x26>
 326:	89 33       	cpi	r24, 0x39	; 57
 328:	91 05       	cpc	r25, r1
 32a:	0c f0       	brlt	.+2      	; 0x32e <__vector_24+0x6a>
 32c:	82 c0       	rjmp	.+260    	; 0x432 <__FUSE_REGION_LENGTH__+0x32>
 32e:	88 32       	cpi	r24, 0x28	; 40
 330:	91 05       	cpc	r25, r1
 332:	99 f0       	breq	.+38     	; 0x35a <__vector_24+0x96>
 334:	89 32       	cpi	r24, 0x29	; 41
 336:	91 05       	cpc	r25, r1
 338:	0c f0       	brlt	.+2      	; 0x33c <__vector_24+0x78>
 33a:	7b c0       	rjmp	.+246    	; 0x432 <__FUSE_REGION_LENGTH__+0x32>
 33c:	88 31       	cpi	r24, 0x18	; 24
 33e:	91 05       	cpc	r25, r1
 340:	61 f0       	breq	.+24     	; 0x35a <__vector_24+0x96>
 342:	89 31       	cpi	r24, 0x19	; 25
 344:	91 05       	cpc	r25, r1
 346:	0c f0       	brlt	.+2      	; 0x34a <__vector_24+0x86>
 348:	74 c0       	rjmp	.+232    	; 0x432 <__FUSE_REGION_LENGTH__+0x32>
 34a:	88 30       	cpi	r24, 0x08	; 8
 34c:	91 05       	cpc	r25, r1
 34e:	19 f0       	breq	.+6      	; 0x356 <__vector_24+0x92>
 350:	40 97       	sbiw	r24, 0x10	; 16
 352:	09 f0       	breq	.+2      	; 0x356 <__vector_24+0x92>
 354:	6e c0       	rjmp	.+220    	; 0x432 <__FUSE_REGION_LENGTH__+0x32>
  {
    case TWI_START:             // START has been transmitted  
    case TWI_REP_START:         // Repeated START has been transmitted
      TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
 356:	10 92 16 01 	sts	0x0116, r1	; 0x800116 <TWI_bufPtr.1563>
    case TWI_MTX_ADR_ACK:       // SLA+W has been transmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been transmitted and ACK received
      if (TWI_bufPtr < TWI_msgSize)
 35a:	90 91 16 01 	lds	r25, 0x0116	; 0x800116 <TWI_bufPtr.1563>
 35e:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <TWI_msgSize>
 362:	98 17       	cp	r25, r24
 364:	b0 f4       	brcc	.+44     	; 0x392 <__vector_24+0xce>
      {
        TWDR = TWI_buf[TWI_bufPtr++];
 366:	80 91 16 01 	lds	r24, 0x0116	; 0x800116 <TWI_bufPtr.1563>
 36a:	91 e0       	ldi	r25, 0x01	; 1
 36c:	98 0f       	add	r25, r24
 36e:	90 93 16 01 	sts	0x0116, r25	; 0x800116 <TWI_bufPtr.1563>
 372:	28 2f       	mov	r18, r24
 374:	30 e0       	ldi	r19, 0x00	; 0
 376:	8b eb       	ldi	r24, 0xBB	; 187
 378:	90 e0       	ldi	r25, 0x00	; 0
 37a:	20 5f       	subi	r18, 0xF0	; 240
 37c:	3e 4f       	sbci	r19, 0xFE	; 254
 37e:	f9 01       	movw	r30, r18
 380:	20 81       	ld	r18, Z
 382:	fc 01       	movw	r30, r24
 384:	20 83       	st	Z, r18
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 386:	8c eb       	ldi	r24, 0xBC	; 188
 388:	90 e0       	ldi	r25, 0x00	; 0
 38a:	25 e8       	ldi	r18, 0x85	; 133
 38c:	fc 01       	movw	r30, r24
 38e:	20 83       	st	Z, r18
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
               (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
               (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
               (0<<TWWC);                                 //
      }
      break;
 390:	5c c0       	rjmp	.+184    	; 0x44a <__FUSE_REGION_LENGTH__+0x4a>
        TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
 392:	80 91 15 01 	lds	r24, 0x0115	; 0x800115 <TWI_statusReg>
 396:	81 60       	ori	r24, 0x01	; 1
 398:	80 93 15 01 	sts	0x0115, r24	; 0x800115 <TWI_statusReg>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 39c:	8c eb       	ldi	r24, 0xBC	; 188
 39e:	90 e0       	ldi	r25, 0x00	; 0
 3a0:	24 e9       	ldi	r18, 0x94	; 148
 3a2:	fc 01       	movw	r30, r24
 3a4:	20 83       	st	Z, r18
      break;
 3a6:	51 c0       	rjmp	.+162    	; 0x44a <__FUSE_REGION_LENGTH__+0x4a>
    case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK transmitted
      TWI_buf[TWI_bufPtr++] = TWDR;
 3a8:	2b eb       	ldi	r18, 0xBB	; 187
 3aa:	30 e0       	ldi	r19, 0x00	; 0
 3ac:	80 91 16 01 	lds	r24, 0x0116	; 0x800116 <TWI_bufPtr.1563>
 3b0:	91 e0       	ldi	r25, 0x01	; 1
 3b2:	98 0f       	add	r25, r24
 3b4:	90 93 16 01 	sts	0x0116, r25	; 0x800116 <TWI_bufPtr.1563>
 3b8:	88 2f       	mov	r24, r24
 3ba:	90 e0       	ldi	r25, 0x00	; 0
 3bc:	f9 01       	movw	r30, r18
 3be:	20 81       	ld	r18, Z
 3c0:	80 5f       	subi	r24, 0xF0	; 240
 3c2:	9e 4f       	sbci	r25, 0xFE	; 254
 3c4:	fc 01       	movw	r30, r24
 3c6:	20 83       	st	Z, r18
    case TWI_MRX_ADR_ACK:       // SLA+R has been transmitted and ACK received
      if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
 3c8:	80 91 16 01 	lds	r24, 0x0116	; 0x800116 <TWI_bufPtr.1563>
 3cc:	28 2f       	mov	r18, r24
 3ce:	30 e0       	ldi	r19, 0x00	; 0
 3d0:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <TWI_msgSize>
 3d4:	88 2f       	mov	r24, r24
 3d6:	90 e0       	ldi	r25, 0x00	; 0
 3d8:	01 97       	sbiw	r24, 0x01	; 1
 3da:	28 17       	cp	r18, r24
 3dc:	39 07       	cpc	r19, r25
 3de:	34 f4       	brge	.+12     	; 0x3ec <__vector_24+0x128>
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 3e0:	8c eb       	ldi	r24, 0xBC	; 188
 3e2:	90 e0       	ldi	r25, 0x00	; 0
 3e4:	25 ec       	ldi	r18, 0xC5	; 197
 3e6:	fc 01       	movw	r30, r24
 3e8:	20 83       	st	Z, r18
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to read next byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
               (0<<TWWC);                                 // 
      }    
      break; 
 3ea:	2f c0       	rjmp	.+94     	; 0x44a <__FUSE_REGION_LENGTH__+0x4a>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 3ec:	8c eb       	ldi	r24, 0xBC	; 188
 3ee:	90 e0       	ldi	r25, 0x00	; 0
 3f0:	25 e8       	ldi	r18, 0x85	; 133
 3f2:	fc 01       	movw	r30, r24
 3f4:	20 83       	st	Z, r18
      break; 
 3f6:	29 c0       	rjmp	.+82     	; 0x44a <__FUSE_REGION_LENGTH__+0x4a>
    case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK transmitted
      TWI_buf[TWI_bufPtr] = TWDR;
 3f8:	2b eb       	ldi	r18, 0xBB	; 187
 3fa:	30 e0       	ldi	r19, 0x00	; 0
 3fc:	80 91 16 01 	lds	r24, 0x0116	; 0x800116 <TWI_bufPtr.1563>
 400:	88 2f       	mov	r24, r24
 402:	90 e0       	ldi	r25, 0x00	; 0
 404:	f9 01       	movw	r30, r18
 406:	20 81       	ld	r18, Z
 408:	80 5f       	subi	r24, 0xF0	; 240
 40a:	9e 4f       	sbci	r25, 0xFE	; 254
 40c:	fc 01       	movw	r30, r24
 40e:	20 83       	st	Z, r18
      TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
 410:	80 91 15 01 	lds	r24, 0x0115	; 0x800115 <TWI_statusReg>
 414:	81 60       	ori	r24, 0x01	; 1
 416:	80 93 15 01 	sts	0x0115, r24	; 0x800115 <TWI_statusReg>
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 41a:	8c eb       	ldi	r24, 0xBC	; 188
 41c:	90 e0       	ldi	r25, 0x00	; 0
 41e:	24 e9       	ldi	r18, 0x94	; 148
 420:	fc 01       	movw	r30, r24
 422:	20 83       	st	Z, r18
             (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
      break;      
 424:	12 c0       	rjmp	.+36     	; 0x44a <__FUSE_REGION_LENGTH__+0x4a>
    case TWI_ARB_LOST:          // Arbitration lost
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 426:	8c eb       	ldi	r24, 0xBC	; 188
 428:	90 e0       	ldi	r25, 0x00	; 0
 42a:	25 ea       	ldi	r18, 0xA5	; 165
 42c:	fc 01       	movw	r30, r24
 42e:	20 83       	st	Z, r18
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag
             (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
             (0<<TWWC);                                 //
      break;
 430:	0c c0       	rjmp	.+24     	; 0x44a <__FUSE_REGION_LENGTH__+0x4a>
    case TWI_MTX_ADR_NACK:      // SLA+W has been transmitted and NACK received
    case TWI_MRX_ADR_NACK:      // SLA+R has been transmitted and NACK received    
    case TWI_MTX_DATA_NACK:     // Data byte has been transmitted and NACK received
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    default:     
      TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
 432:	89 eb       	ldi	r24, 0xB9	; 185
 434:	90 e0       	ldi	r25, 0x00	; 0
 436:	fc 01       	movw	r30, r24
 438:	80 81       	ld	r24, Z
 43a:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
                                                        // Reset TWI Interface
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
 43e:	8c eb       	ldi	r24, 0xBC	; 188
 440:	90 e0       	ldi	r25, 0x00	; 0
 442:	24 e0       	ldi	r18, 0x04	; 4
 444:	fc 01       	movw	r30, r24
 446:	20 83       	st	Z, r18
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interrupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }
}
 448:	00 00       	nop
 44a:	00 00       	nop
 44c:	df 91       	pop	r29
 44e:	cf 91       	pop	r28
 450:	ff 91       	pop	r31
 452:	ef 91       	pop	r30
 454:	9f 91       	pop	r25
 456:	8f 91       	pop	r24
 458:	3f 91       	pop	r19
 45a:	2f 91       	pop	r18
 45c:	0f 90       	pop	r0
 45e:	0f be       	out	0x3f, r0	; 63
 460:	0f 90       	pop	r0
 462:	1f 90       	pop	r1
 464:	18 95       	reti

00000466 <get_usart_stream>:

/* Stream init for printf  */
FILE usart_str = FDEV_SETUP_STREAM(usart_putchar, NULL, _FDEV_SETUP_WRITE);

/* Return stream pointer  */
FILE * get_usart_stream(){
 466:	cf 93       	push	r28
 468:	df 93       	push	r29
 46a:	cd b7       	in	r28, 0x3d	; 61
 46c:	de b7       	in	r29, 0x3e	; 62
	return &usart_str;
 46e:	81 e0       	ldi	r24, 0x01	; 1
 470:	91 e0       	ldi	r25, 0x01	; 1
}
 472:	df 91       	pop	r29
 474:	cf 91       	pop	r28
 476:	08 95       	ret

00000478 <USART_Init>:

void USART_Init(uint16_t bauds){
 478:	cf 93       	push	r28
 47a:	df 93       	push	r29
 47c:	00 d0       	rcall	.+0      	; 0x47e <USART_Init+0x6>
 47e:	cd b7       	in	r28, 0x3d	; 61
 480:	de b7       	in	r29, 0x3e	; 62
 482:	9a 83       	std	Y+2, r25	; 0x02
 484:	89 83       	std	Y+1, r24	; 0x01

	USART_0->UBRR_H = (uint8_t) (bauds >> 8);
 486:	89 81       	ldd	r24, Y+1	; 0x01
 488:	9a 81       	ldd	r25, Y+2	; 0x02
 48a:	29 2f       	mov	r18, r25
 48c:	33 27       	eor	r19, r19
 48e:	80 ec       	ldi	r24, 0xC0	; 192
 490:	90 e0       	ldi	r25, 0x00	; 0
 492:	fc 01       	movw	r30, r24
 494:	25 83       	std	Z+5, r18	; 0x05
	USART_0->UBRR_L = bauds;
 496:	80 ec       	ldi	r24, 0xC0	; 192
 498:	90 e0       	ldi	r25, 0x00	; 0
 49a:	29 81       	ldd	r18, Y+1	; 0x01
 49c:	fc 01       	movw	r30, r24
 49e:	24 83       	std	Z+4, r18	; 0x04

	/* Disable double speed  */
	USART_0->UCSR_A = 0;
 4a0:	80 ec       	ldi	r24, 0xC0	; 192
 4a2:	90 e0       	ldi	r25, 0x00	; 0
 4a4:	fc 01       	movw	r30, r24
 4a6:	10 82       	st	Z, r1
	/* Enable TX and RX */
	USART_0->UCSR_B = SET(RXEN0) | SET(TXEN0) | SET(RXCIE0);
 4a8:	80 ec       	ldi	r24, 0xC0	; 192
 4aa:	90 e0       	ldi	r25, 0x00	; 0
 4ac:	28 e9       	ldi	r18, 0x98	; 152
 4ae:	fc 01       	movw	r30, r24
 4b0:	21 83       	std	Z+1, r18	; 0x01
	/* Asynchronous mode:
	 * - 8 data bits
	 * - 1 stop bit
	 * - no parity 	 */
	USART_0->UCSR_C = SET(UCSZ01) | SET(UCSZ00);
 4b2:	80 ec       	ldi	r24, 0xC0	; 192
 4b4:	90 e0       	ldi	r25, 0x00	; 0
 4b6:	26 e0       	ldi	r18, 0x06	; 6
 4b8:	fc 01       	movw	r30, r24
 4ba:	22 83       	std	Z+2, r18	; 0x02
}
 4bc:	00 00       	nop
 4be:	0f 90       	pop	r0
 4c0:	0f 90       	pop	r0
 4c2:	df 91       	pop	r29
 4c4:	cf 91       	pop	r28
 4c6:	08 95       	ret

000004c8 <USART_tx>:


/* Send one byte: busy waiting */
void USART_tx(uint8_t data) {
 4c8:	cf 93       	push	r28
 4ca:	df 93       	push	r29
 4cc:	0f 92       	push	r0
 4ce:	cd b7       	in	r28, 0x3d	; 61
 4d0:	de b7       	in	r29, 0x3e	; 62
 4d2:	89 83       	std	Y+1, r24	; 0x01

	/* Wait until hardware is ready */
	while (!(USART_0->UCSR_A & (1 << UDRE0)));
 4d4:	00 00       	nop
 4d6:	80 ec       	ldi	r24, 0xC0	; 192
 4d8:	90 e0       	ldi	r25, 0x00	; 0
 4da:	fc 01       	movw	r30, r24
 4dc:	80 81       	ld	r24, Z
 4de:	88 2f       	mov	r24, r24
 4e0:	90 e0       	ldi	r25, 0x00	; 0
 4e2:	80 72       	andi	r24, 0x20	; 32
 4e4:	99 27       	eor	r25, r25
 4e6:	89 2b       	or	r24, r25
 4e8:	b1 f3       	breq	.-20     	; 0x4d6 <USART_tx+0xe>

	USART_0->UDR_ = data;
 4ea:	80 ec       	ldi	r24, 0xC0	; 192
 4ec:	90 e0       	ldi	r25, 0x00	; 0
 4ee:	29 81       	ldd	r18, Y+1	; 0x01
 4f0:	fc 01       	movw	r30, r24
 4f2:	26 83       	std	Z+6, r18	; 0x06
}
 4f4:	00 00       	nop
 4f6:	0f 90       	pop	r0
 4f8:	df 91       	pop	r29
 4fa:	cf 91       	pop	r28
 4fc:	08 95       	ret

000004fe <USART_rx>:

/* Receive one byte: busy waiting */
uint8_t USART_rx() {
 4fe:	cf 93       	push	r28
 500:	df 93       	push	r29
 502:	cd b7       	in	r28, 0x3d	; 61
 504:	de b7       	in	r29, 0x3e	; 62

	/* Wait until something arrive  */
	while (!(USART_0->UCSR_A & (1 << RXC0)));
 506:	00 00       	nop
 508:	80 ec       	ldi	r24, 0xC0	; 192
 50a:	90 e0       	ldi	r25, 0x00	; 0
 50c:	fc 01       	movw	r30, r24
 50e:	80 81       	ld	r24, Z
 510:	88 23       	and	r24, r24
 512:	d4 f7       	brge	.-12     	; 0x508 <USART_rx+0xa>

	return USART_0->UDR_;
 514:	80 ec       	ldi	r24, 0xC0	; 192
 516:	90 e0       	ldi	r25, 0x00	; 0
 518:	fc 01       	movw	r30, r24
 51a:	86 81       	ldd	r24, Z+6	; 0x06
}
 51c:	df 91       	pop	r29
 51e:	cf 91       	pop	r28
 520:	08 95       	ret

00000522 <usart_putchar>:


static int usart_putchar(char c, FILE *fp){
 522:	cf 93       	push	r28
 524:	df 93       	push	r29
 526:	00 d0       	rcall	.+0      	; 0x528 <usart_putchar+0x6>
 528:	0f 92       	push	r0
 52a:	cd b7       	in	r28, 0x3d	; 61
 52c:	de b7       	in	r29, 0x3e	; 62
 52e:	89 83       	std	Y+1, r24	; 0x01
 530:	7b 83       	std	Y+3, r23	; 0x03
 532:	6a 83       	std	Y+2, r22	; 0x02
	USART_tx(c);
 534:	89 81       	ldd	r24, Y+1	; 0x01
 536:	0e 94 64 02 	call	0x4c8	; 0x4c8 <USART_tx>

	return 0;
 53a:	80 e0       	ldi	r24, 0x00	; 0
 53c:	90 e0       	ldi	r25, 0x00	; 0
}
 53e:	0f 90       	pop	r0
 540:	0f 90       	pop	r0
 542:	0f 90       	pop	r0
 544:	df 91       	pop	r29
 546:	cf 91       	pop	r28
 548:	08 95       	ret

0000054a <display_init>:
#ifdef COM_CATODO
const uint8_t convTable[] PROGMEM = { ...  };
#endif


void display_init() {
 54a:	cf 93       	push	r28
 54c:	df 93       	push	r29
 54e:	cd b7       	in	r28, 0x3d	; 61
 550:	de b7       	in	r29, 0x3e	; 62

	/* Configuração de portas */
	//DISPLAY_PORT->DDR = (...)


}
 552:	00 00       	nop
 554:	df 91       	pop	r29
 556:	cf 91       	pop	r28
 558:	08 95       	ret

0000055a <display_write>:

void display_write(uint8_t data){
 55a:	cf 93       	push	r28
 55c:	df 93       	push	r29
 55e:	0f 92       	push	r0
 560:	cd b7       	in	r28, 0x3d	; 61
 562:	de b7       	in	r29, 0x3e	; 62
 564:	89 83       	std	Y+1, r24	; 0x01

	/* Escreve no display */
	//DISPLAY_PORT->PORT = (...)

}
 566:	00 00       	nop
 568:	0f 90       	pop	r0
 56a:	df 91       	pop	r29
 56c:	cf 91       	pop	r28
 56e:	08 95       	ret

00000570 <hardware_init>:
  * @brief  Configura hardware.
  * @param	Nenhum
  *
  * @retval Nenhum.
  */
void hardware_init(){
 570:	cf 93       	push	r28
 572:	df 93       	push	r29
 574:	cd b7       	in	r28, 0x3d	; 61
 576:	de b7       	in	r29, 0x3e	; 62
	/* OU */

	/* Acesso por struct:
	 * Vantagem da estrutura: agrupamento
	 * dos registradores do periférico */
	GPIO_B->DDR = PB5;
 578:	83 e2       	ldi	r24, 0x23	; 35
 57a:	90 e0       	ldi	r25, 0x00	; 0
 57c:	25 e0       	ldi	r18, 0x05	; 5
 57e:	fc 01       	movw	r30, r24
 580:	21 83       	std	Z+1, r18	; 0x01
	GPIO_B->PORT =PB0;
 582:	83 e2       	ldi	r24, 0x23	; 35
 584:	90 e0       	ldi	r25, 0x00	; 0
 586:	fc 01       	movw	r30, r24
 588:	12 82       	std	Z+2, r1	; 0x02
	/* OU */

	/* Melhor documentação: macros */
	//LED_PORT->DDR = SET(LED_PIN);
	//BTN_PORT->PORT = SET(BTN_PIN);
}
 58a:	00 00       	nop
 58c:	df 91       	pop	r29
 58e:	cf 91       	pop	r28
 590:	08 95       	ret

00000592 <main>:


int main(){
 592:	cf 93       	push	r28
 594:	df 93       	push	r29
 596:	cd b7       	in	r28, 0x3d	; 61
 598:	de b7       	in	r29, 0x3e	; 62
 59a:	c4 54       	subi	r28, 0x44	; 68
 59c:	d1 09       	sbc	r29, r1
 59e:	0f b6       	in	r0, 0x3f	; 63
 5a0:	f8 94       	cli
 5a2:	de bf       	out	0x3e, r29	; 62
 5a4:	0f be       	out	0x3f, r0	; 63
 5a6:	cd bf       	out	0x3d, r28	; 61
	/* Configura hardware do projeto */
	hardware_init();
 5a8:	0e 94 b8 02 	call	0x570	; 0x570 <hardware_init>

	/* Pisca LED: set/clear + delay */
	while(1){
		SET_BIT(PORTB, LED_PIN);
 5ac:	85 e2       	ldi	r24, 0x25	; 37
 5ae:	90 e0       	ldi	r25, 0x00	; 0
 5b0:	dc 01       	movw	r26, r24
 5b2:	2c 91       	ld	r18, X
 5b4:	85 e2       	ldi	r24, 0x25	; 37
 5b6:	90 e0       	ldi	r25, 0x00	; 0
 5b8:	20 62       	ori	r18, 0x20	; 32
 5ba:	fc 01       	movw	r30, r24
 5bc:	20 83       	st	Z, r18
 5be:	80 e0       	ldi	r24, 0x00	; 0
 5c0:	90 e0       	ldi	r25, 0x00	; 0
 5c2:	aa ef       	ldi	r26, 0xFA	; 250
 5c4:	b3 e4       	ldi	r27, 0x43	; 67
 5c6:	8f 87       	std	Y+15, r24	; 0x0f
 5c8:	98 8b       	std	Y+16, r25	; 0x10
 5ca:	a9 8b       	std	Y+17, r26	; 0x11
 5cc:	ba 8b       	std	Y+18, r27	; 0x12

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
 5ce:	20 e0       	ldi	r18, 0x00	; 0
 5d0:	30 e0       	ldi	r19, 0x00	; 0
 5d2:	4a e7       	ldi	r20, 0x7A	; 122
 5d4:	55 e4       	ldi	r21, 0x45	; 69
 5d6:	6f 85       	ldd	r22, Y+15	; 0x0f
 5d8:	78 89       	ldd	r23, Y+16	; 0x10
 5da:	89 89       	ldd	r24, Y+17	; 0x11
 5dc:	9a 89       	ldd	r25, Y+18	; 0x12
 5de:	0e 94 92 04 	call	0x924	; 0x924 <__mulsf3>
 5e2:	6d a3       	std	Y+37, r22	; 0x25
 5e4:	7e a3       	std	Y+38, r23	; 0x26
 5e6:	8f a3       	std	Y+39, r24	; 0x27
 5e8:	98 a7       	std	Y+40, r25	; 0x28
 5ea:	8d a1       	ldd	r24, Y+37	; 0x25
 5ec:	9e a1       	ldd	r25, Y+38	; 0x26
 5ee:	af a1       	ldd	r26, Y+39	; 0x27
 5f0:	b8 a5       	ldd	r27, Y+40	; 0x28
 5f2:	8b 8b       	std	Y+19, r24	; 0x13
 5f4:	9c 8b       	std	Y+20, r25	; 0x14
 5f6:	ad 8b       	std	Y+21, r26	; 0x15
 5f8:	be 8b       	std	Y+22, r27	; 0x16
	if (__tmp < 1.0)
 5fa:	20 e0       	ldi	r18, 0x00	; 0
 5fc:	30 e0       	ldi	r19, 0x00	; 0
 5fe:	40 e8       	ldi	r20, 0x80	; 128
 600:	5f e3       	ldi	r21, 0x3F	; 63
 602:	6b 89       	ldd	r22, Y+19	; 0x13
 604:	7c 89       	ldd	r23, Y+20	; 0x14
 606:	8d 89       	ldd	r24, Y+21	; 0x15
 608:	9e 89       	ldd	r25, Y+22	; 0x16
 60a:	0e 94 0c 04 	call	0x818	; 0x818 <__cmpsf2>
 60e:	88 23       	and	r24, r24
 610:	2c f4       	brge	.+10     	; 0x61c <main+0x8a>
		__ticks = 1;
 612:	81 e0       	ldi	r24, 0x01	; 1
 614:	90 e0       	ldi	r25, 0x00	; 0
 616:	98 8f       	std	Y+24, r25	; 0x18
 618:	8f 8b       	std	Y+23, r24	; 0x17
 61a:	54 c0       	rjmp	.+168    	; 0x6c4 <main+0x132>
	else if (__tmp > 65535)
 61c:	20 e0       	ldi	r18, 0x00	; 0
 61e:	3f ef       	ldi	r19, 0xFF	; 255
 620:	4f e7       	ldi	r20, 0x7F	; 127
 622:	57 e4       	ldi	r21, 0x47	; 71
 624:	6b 89       	ldd	r22, Y+19	; 0x13
 626:	7c 89       	ldd	r23, Y+20	; 0x14
 628:	8d 89       	ldd	r24, Y+21	; 0x15
 62a:	9e 89       	ldd	r25, Y+22	; 0x16
 62c:	0e 94 8d 04 	call	0x91a	; 0x91a <__gesf2>
 630:	18 16       	cp	r1, r24
 632:	d4 f5       	brge	.+116    	; 0x6a8 <main+0x116>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
 634:	20 e0       	ldi	r18, 0x00	; 0
 636:	30 e0       	ldi	r19, 0x00	; 0
 638:	40 e2       	ldi	r20, 0x20	; 32
 63a:	51 e4       	ldi	r21, 0x41	; 65
 63c:	6f 85       	ldd	r22, Y+15	; 0x0f
 63e:	78 89       	ldd	r23, Y+16	; 0x10
 640:	89 89       	ldd	r24, Y+17	; 0x11
 642:	9a 89       	ldd	r25, Y+18	; 0x12
 644:	0e 94 92 04 	call	0x924	; 0x924 <__mulsf3>
 648:	69 a7       	std	Y+41, r22	; 0x29
 64a:	7a a7       	std	Y+42, r23	; 0x2a
 64c:	8b a7       	std	Y+43, r24	; 0x2b
 64e:	9c a7       	std	Y+44, r25	; 0x2c
 650:	89 a5       	ldd	r24, Y+41	; 0x29
 652:	9a a5       	ldd	r25, Y+42	; 0x2a
 654:	ab a5       	ldd	r26, Y+43	; 0x2b
 656:	bc a5       	ldd	r27, Y+44	; 0x2c
 658:	89 a3       	std	Y+33, r24	; 0x21
 65a:	9a a3       	std	Y+34, r25	; 0x22
 65c:	ab a3       	std	Y+35, r26	; 0x23
 65e:	bc a3       	std	Y+36, r27	; 0x24
 660:	69 a1       	ldd	r22, Y+33	; 0x21
 662:	7a a1       	ldd	r23, Y+34	; 0x22
 664:	8b a1       	ldd	r24, Y+35	; 0x23
 666:	9c a1       	ldd	r25, Y+36	; 0x24
 668:	0e 94 11 04 	call	0x822	; 0x822 <__fixunssfsi>
 66c:	6d a7       	std	Y+45, r22	; 0x2d
 66e:	7e a7       	std	Y+46, r23	; 0x2e
 670:	8f a7       	std	Y+47, r24	; 0x2f
 672:	98 ab       	std	Y+48, r25	; 0x30
 674:	ad a5       	ldd	r26, Y+45	; 0x2d
 676:	be a5       	ldd	r27, Y+46	; 0x2e
 678:	b8 8f       	std	Y+24, r27	; 0x18
 67a:	af 8b       	std	Y+23, r26	; 0x17
		while(__ticks)
 67c:	10 c0       	rjmp	.+32     	; 0x69e <main+0x10c>
 67e:	80 e9       	ldi	r24, 0x90	; 144
 680:	91 e0       	ldi	r25, 0x01	; 1
 682:	9a 8f       	std	Y+26, r25	; 0x1a
 684:	89 8f       	std	Y+25, r24	; 0x19
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 686:	89 8d       	ldd	r24, Y+25	; 0x19
 688:	9a 8d       	ldd	r25, Y+26	; 0x1a
 68a:	01 97       	sbiw	r24, 0x01	; 1
 68c:	f1 f7       	brne	.-4      	; 0x68a <main+0xf8>
 68e:	9a 8f       	std	Y+26, r25	; 0x1a
 690:	89 8f       	std	Y+25, r24	; 0x19
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
}
 692:	00 00       	nop
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 694:	8f 89       	ldd	r24, Y+23	; 0x17
 696:	98 8d       	ldd	r25, Y+24	; 0x18
 698:	01 97       	sbiw	r24, 0x01	; 1
 69a:	98 8f       	std	Y+24, r25	; 0x18
 69c:	8f 8b       	std	Y+23, r24	; 0x17
		while(__ticks)
 69e:	8f 89       	ldd	r24, Y+23	; 0x17
 6a0:	98 8d       	ldd	r25, Y+24	; 0x18
 6a2:	89 2b       	or	r24, r25
 6a4:	61 f7       	brne	.-40     	; 0x67e <main+0xec>
		}
		return;
 6a6:	19 c0       	rjmp	.+50     	; 0x6da <main+0x148>
	}
	else
		__ticks = (uint16_t)__tmp;
 6a8:	6b 89       	ldd	r22, Y+19	; 0x13
 6aa:	7c 89       	ldd	r23, Y+20	; 0x14
 6ac:	8d 89       	ldd	r24, Y+21	; 0x15
 6ae:	9e 89       	ldd	r25, Y+22	; 0x16
 6b0:	0e 94 11 04 	call	0x822	; 0x822 <__fixunssfsi>
 6b4:	69 ab       	std	Y+49, r22	; 0x31
 6b6:	7a ab       	std	Y+50, r23	; 0x32
 6b8:	8b ab       	std	Y+51, r24	; 0x33
 6ba:	9c ab       	std	Y+52, r25	; 0x34
 6bc:	e9 a9       	ldd	r30, Y+49	; 0x31
 6be:	fa a9       	ldd	r31, Y+50	; 0x32
 6c0:	f8 8f       	std	Y+24, r31	; 0x18
 6c2:	ef 8b       	std	Y+23, r30	; 0x17
 6c4:	8f 89       	ldd	r24, Y+23	; 0x17
 6c6:	98 8d       	ldd	r25, Y+24	; 0x18
 6c8:	9c 8f       	std	Y+28, r25	; 0x1c
 6ca:	8b 8f       	std	Y+27, r24	; 0x1b
	__asm__ volatile (
 6cc:	8b 8d       	ldd	r24, Y+27	; 0x1b
 6ce:	9c 8d       	ldd	r25, Y+28	; 0x1c
 6d0:	01 97       	sbiw	r24, 0x01	; 1
 6d2:	f1 f7       	brne	.-4      	; 0x6d0 <main+0x13e>
 6d4:	9c 8f       	std	Y+28, r25	; 0x1c
 6d6:	8b 8f       	std	Y+27, r24	; 0x1b
}
 6d8:	00 00       	nop
		_delay_ms(500);
		CLR_BIT(PORTB,LED_PIN);
 6da:	85 e2       	ldi	r24, 0x25	; 37
 6dc:	90 e0       	ldi	r25, 0x00	; 0
 6de:	dc 01       	movw	r26, r24
 6e0:	2c 91       	ld	r18, X
 6e2:	85 e2       	ldi	r24, 0x25	; 37
 6e4:	90 e0       	ldi	r25, 0x00	; 0
 6e6:	2f 7d       	andi	r18, 0xDF	; 223
 6e8:	fc 01       	movw	r30, r24
 6ea:	20 83       	st	Z, r18
 6ec:	80 e0       	ldi	r24, 0x00	; 0
 6ee:	90 e0       	ldi	r25, 0x00	; 0
 6f0:	aa ef       	ldi	r26, 0xFA	; 250
 6f2:	b3 e4       	ldi	r27, 0x43	; 67
 6f4:	89 83       	std	Y+1, r24	; 0x01
 6f6:	9a 83       	std	Y+2, r25	; 0x02
 6f8:	ab 83       	std	Y+3, r26	; 0x03
 6fa:	bc 83       	std	Y+4, r27	; 0x04
	__tmp = ((F_CPU) / 4e3) * __ms;
 6fc:	20 e0       	ldi	r18, 0x00	; 0
 6fe:	30 e0       	ldi	r19, 0x00	; 0
 700:	4a e7       	ldi	r20, 0x7A	; 122
 702:	55 e4       	ldi	r21, 0x45	; 69
 704:	69 81       	ldd	r22, Y+1	; 0x01
 706:	7a 81       	ldd	r23, Y+2	; 0x02
 708:	8b 81       	ldd	r24, Y+3	; 0x03
 70a:	9c 81       	ldd	r25, Y+4	; 0x04
 70c:	0e 94 92 04 	call	0x924	; 0x924 <__mulsf3>
 710:	6d ab       	std	Y+53, r22	; 0x35
 712:	7e ab       	std	Y+54, r23	; 0x36
 714:	8f ab       	std	Y+55, r24	; 0x37
 716:	98 af       	std	Y+56, r25	; 0x38
 718:	8d a9       	ldd	r24, Y+53	; 0x35
 71a:	9e a9       	ldd	r25, Y+54	; 0x36
 71c:	af a9       	ldd	r26, Y+55	; 0x37
 71e:	b8 ad       	ldd	r27, Y+56	; 0x38
 720:	8d 83       	std	Y+5, r24	; 0x05
 722:	9e 83       	std	Y+6, r25	; 0x06
 724:	af 83       	std	Y+7, r26	; 0x07
 726:	b8 87       	std	Y+8, r27	; 0x08
	if (__tmp < 1.0)
 728:	20 e0       	ldi	r18, 0x00	; 0
 72a:	30 e0       	ldi	r19, 0x00	; 0
 72c:	40 e8       	ldi	r20, 0x80	; 128
 72e:	5f e3       	ldi	r21, 0x3F	; 63
 730:	6d 81       	ldd	r22, Y+5	; 0x05
 732:	7e 81       	ldd	r23, Y+6	; 0x06
 734:	8f 81       	ldd	r24, Y+7	; 0x07
 736:	98 85       	ldd	r25, Y+8	; 0x08
 738:	0e 94 0c 04 	call	0x818	; 0x818 <__cmpsf2>
 73c:	88 23       	and	r24, r24
 73e:	2c f4       	brge	.+10     	; 0x74a <main+0x1b8>
		__ticks = 1;
 740:	81 e0       	ldi	r24, 0x01	; 1
 742:	90 e0       	ldi	r25, 0x00	; 0
 744:	9a 87       	std	Y+10, r25	; 0x0a
 746:	89 87       	std	Y+9, r24	; 0x09
 748:	5b c0       	rjmp	.+182    	; 0x800 <main+0x26e>
	else if (__tmp > 65535)
 74a:	20 e0       	ldi	r18, 0x00	; 0
 74c:	3f ef       	ldi	r19, 0xFF	; 255
 74e:	4f e7       	ldi	r20, 0x7F	; 127
 750:	57 e4       	ldi	r21, 0x47	; 71
 752:	6d 81       	ldd	r22, Y+5	; 0x05
 754:	7e 81       	ldd	r23, Y+6	; 0x06
 756:	8f 81       	ldd	r24, Y+7	; 0x07
 758:	98 85       	ldd	r25, Y+8	; 0x08
 75a:	0e 94 8d 04 	call	0x91a	; 0x91a <__gesf2>
 75e:	18 16       	cp	r1, r24
 760:	0c f0       	brlt	.+2      	; 0x764 <main+0x1d2>
 762:	3c c0       	rjmp	.+120    	; 0x7dc <main+0x24a>
		__ticks = (uint16_t) (__ms * 10.0);
 764:	20 e0       	ldi	r18, 0x00	; 0
 766:	30 e0       	ldi	r19, 0x00	; 0
 768:	40 e2       	ldi	r20, 0x20	; 32
 76a:	51 e4       	ldi	r21, 0x41	; 65
 76c:	69 81       	ldd	r22, Y+1	; 0x01
 76e:	7a 81       	ldd	r23, Y+2	; 0x02
 770:	8b 81       	ldd	r24, Y+3	; 0x03
 772:	9c 81       	ldd	r25, Y+4	; 0x04
 774:	0e 94 92 04 	call	0x924	; 0x924 <__mulsf3>
 778:	69 af       	std	Y+57, r22	; 0x39
 77a:	7a af       	std	Y+58, r23	; 0x3a
 77c:	8b af       	std	Y+59, r24	; 0x3b
 77e:	9c af       	std	Y+60, r25	; 0x3c
 780:	89 ad       	ldd	r24, Y+57	; 0x39
 782:	9a ad       	ldd	r25, Y+58	; 0x3a
 784:	ab ad       	ldd	r26, Y+59	; 0x3b
 786:	bc ad       	ldd	r27, Y+60	; 0x3c
 788:	8d 8f       	std	Y+29, r24	; 0x1d
 78a:	9e 8f       	std	Y+30, r25	; 0x1e
 78c:	af 8f       	std	Y+31, r26	; 0x1f
 78e:	b8 a3       	std	Y+32, r27	; 0x20
 790:	6d 8d       	ldd	r22, Y+29	; 0x1d
 792:	7e 8d       	ldd	r23, Y+30	; 0x1e
 794:	8f 8d       	ldd	r24, Y+31	; 0x1f
 796:	98 a1       	ldd	r25, Y+32	; 0x20
 798:	0e 94 11 04 	call	0x822	; 0x822 <__fixunssfsi>
 79c:	21 96       	adiw	r28, 0x01	; 1
 79e:	6c af       	std	Y+60, r22	; 0x3c
 7a0:	7d af       	std	Y+61, r23	; 0x3d
 7a2:	8e af       	std	Y+62, r24	; 0x3e
 7a4:	9f af       	std	Y+63, r25	; 0x3f
 7a6:	21 97       	sbiw	r28, 0x01	; 1
 7a8:	ad ad       	ldd	r26, Y+61	; 0x3d
 7aa:	be ad       	ldd	r27, Y+62	; 0x3e
 7ac:	ba 87       	std	Y+10, r27	; 0x0a
 7ae:	a9 87       	std	Y+9, r26	; 0x09
		while(__ticks)
 7b0:	10 c0       	rjmp	.+32     	; 0x7d2 <main+0x240>
 7b2:	80 e9       	ldi	r24, 0x90	; 144
 7b4:	91 e0       	ldi	r25, 0x01	; 1
 7b6:	9c 87       	std	Y+12, r25	; 0x0c
 7b8:	8b 87       	std	Y+11, r24	; 0x0b
	__asm__ volatile (
 7ba:	8b 85       	ldd	r24, Y+11	; 0x0b
 7bc:	9c 85       	ldd	r25, Y+12	; 0x0c
 7be:	01 97       	sbiw	r24, 0x01	; 1
 7c0:	f1 f7       	brne	.-4      	; 0x7be <main+0x22c>
 7c2:	9c 87       	std	Y+12, r25	; 0x0c
 7c4:	8b 87       	std	Y+11, r24	; 0x0b
}
 7c6:	00 00       	nop
			__ticks --;
 7c8:	89 85       	ldd	r24, Y+9	; 0x09
 7ca:	9a 85       	ldd	r25, Y+10	; 0x0a
 7cc:	01 97       	sbiw	r24, 0x01	; 1
 7ce:	9a 87       	std	Y+10, r25	; 0x0a
 7d0:	89 87       	std	Y+9, r24	; 0x09
		while(__ticks)
 7d2:	89 85       	ldd	r24, Y+9	; 0x09
 7d4:	9a 85       	ldd	r25, Y+10	; 0x0a
 7d6:	89 2b       	or	r24, r25
 7d8:	61 f7       	brne	.-40     	; 0x7b2 <main+0x220>
		return;
 7da:	1d c0       	rjmp	.+58     	; 0x816 <main+0x284>
		__ticks = (uint16_t)__tmp;
 7dc:	6d 81       	ldd	r22, Y+5	; 0x05
 7de:	7e 81       	ldd	r23, Y+6	; 0x06
 7e0:	8f 81       	ldd	r24, Y+7	; 0x07
 7e2:	98 85       	ldd	r25, Y+8	; 0x08
 7e4:	0e 94 11 04 	call	0x822	; 0x822 <__fixunssfsi>
 7e8:	25 96       	adiw	r28, 0x05	; 5
 7ea:	6c af       	std	Y+60, r22	; 0x3c
 7ec:	7d af       	std	Y+61, r23	; 0x3d
 7ee:	8e af       	std	Y+62, r24	; 0x3e
 7f0:	9f af       	std	Y+63, r25	; 0x3f
 7f2:	25 97       	sbiw	r28, 0x05	; 5
 7f4:	23 96       	adiw	r28, 0x03	; 3
 7f6:	ee ad       	ldd	r30, Y+62	; 0x3e
 7f8:	ff ad       	ldd	r31, Y+63	; 0x3f
 7fa:	23 97       	sbiw	r28, 0x03	; 3
 7fc:	fa 87       	std	Y+10, r31	; 0x0a
 7fe:	e9 87       	std	Y+9, r30	; 0x09
 800:	89 85       	ldd	r24, Y+9	; 0x09
 802:	9a 85       	ldd	r25, Y+10	; 0x0a
 804:	9e 87       	std	Y+14, r25	; 0x0e
 806:	8d 87       	std	Y+13, r24	; 0x0d
	__asm__ volatile (
 808:	8d 85       	ldd	r24, Y+13	; 0x0d
 80a:	9e 85       	ldd	r25, Y+14	; 0x0e
 80c:	01 97       	sbiw	r24, 0x01	; 1
 80e:	f1 f7       	brne	.-4      	; 0x80c <main+0x27a>
 810:	9e 87       	std	Y+14, r25	; 0x0e
 812:	8d 87       	std	Y+13, r24	; 0x0d
}
 814:	00 00       	nop
		SET_BIT(PORTB, LED_PIN);
 816:	ca ce       	rjmp	.-620    	; 0x5ac <main+0x1a>

00000818 <__cmpsf2>:
 818:	0e 94 40 04 	call	0x880	; 0x880 <__fp_cmp>
 81c:	08 f4       	brcc	.+2      	; 0x820 <__cmpsf2+0x8>
 81e:	81 e0       	ldi	r24, 0x01	; 1
 820:	08 95       	ret

00000822 <__fixunssfsi>:
 822:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <__fp_splitA>
 826:	88 f0       	brcs	.+34     	; 0x84a <__fixunssfsi+0x28>
 828:	9f 57       	subi	r25, 0x7F	; 127
 82a:	98 f0       	brcs	.+38     	; 0x852 <__fixunssfsi+0x30>
 82c:	b9 2f       	mov	r27, r25
 82e:	99 27       	eor	r25, r25
 830:	b7 51       	subi	r27, 0x17	; 23
 832:	b0 f0       	brcs	.+44     	; 0x860 <__fixunssfsi+0x3e>
 834:	e1 f0       	breq	.+56     	; 0x86e <__fixunssfsi+0x4c>
 836:	66 0f       	add	r22, r22
 838:	77 1f       	adc	r23, r23
 83a:	88 1f       	adc	r24, r24
 83c:	99 1f       	adc	r25, r25
 83e:	1a f0       	brmi	.+6      	; 0x846 <__fixunssfsi+0x24>
 840:	ba 95       	dec	r27
 842:	c9 f7       	brne	.-14     	; 0x836 <__fixunssfsi+0x14>
 844:	14 c0       	rjmp	.+40     	; 0x86e <__fixunssfsi+0x4c>
 846:	b1 30       	cpi	r27, 0x01	; 1
 848:	91 f0       	breq	.+36     	; 0x86e <__fixunssfsi+0x4c>
 84a:	0e 94 86 04 	call	0x90c	; 0x90c <__fp_zero>
 84e:	b1 e0       	ldi	r27, 0x01	; 1
 850:	08 95       	ret
 852:	0c 94 86 04 	jmp	0x90c	; 0x90c <__fp_zero>
 856:	67 2f       	mov	r22, r23
 858:	78 2f       	mov	r23, r24
 85a:	88 27       	eor	r24, r24
 85c:	b8 5f       	subi	r27, 0xF8	; 248
 85e:	39 f0       	breq	.+14     	; 0x86e <__fixunssfsi+0x4c>
 860:	b9 3f       	cpi	r27, 0xF9	; 249
 862:	cc f3       	brlt	.-14     	; 0x856 <__fixunssfsi+0x34>
 864:	86 95       	lsr	r24
 866:	77 95       	ror	r23
 868:	67 95       	ror	r22
 86a:	b3 95       	inc	r27
 86c:	d9 f7       	brne	.-10     	; 0x864 <__fixunssfsi+0x42>
 86e:	3e f4       	brtc	.+14     	; 0x87e <__fixunssfsi+0x5c>
 870:	90 95       	com	r25
 872:	80 95       	com	r24
 874:	70 95       	com	r23
 876:	61 95       	neg	r22
 878:	7f 4f       	sbci	r23, 0xFF	; 255
 87a:	8f 4f       	sbci	r24, 0xFF	; 255
 87c:	9f 4f       	sbci	r25, 0xFF	; 255
 87e:	08 95       	ret

00000880 <__fp_cmp>:
 880:	99 0f       	add	r25, r25
 882:	00 08       	sbc	r0, r0
 884:	55 0f       	add	r21, r21
 886:	aa 0b       	sbc	r26, r26
 888:	e0 e8       	ldi	r30, 0x80	; 128
 88a:	fe ef       	ldi	r31, 0xFE	; 254
 88c:	16 16       	cp	r1, r22
 88e:	17 06       	cpc	r1, r23
 890:	e8 07       	cpc	r30, r24
 892:	f9 07       	cpc	r31, r25
 894:	c0 f0       	brcs	.+48     	; 0x8c6 <__fp_cmp+0x46>
 896:	12 16       	cp	r1, r18
 898:	13 06       	cpc	r1, r19
 89a:	e4 07       	cpc	r30, r20
 89c:	f5 07       	cpc	r31, r21
 89e:	98 f0       	brcs	.+38     	; 0x8c6 <__fp_cmp+0x46>
 8a0:	62 1b       	sub	r22, r18
 8a2:	73 0b       	sbc	r23, r19
 8a4:	84 0b       	sbc	r24, r20
 8a6:	95 0b       	sbc	r25, r21
 8a8:	39 f4       	brne	.+14     	; 0x8b8 <__fp_cmp+0x38>
 8aa:	0a 26       	eor	r0, r26
 8ac:	61 f0       	breq	.+24     	; 0x8c6 <__fp_cmp+0x46>
 8ae:	23 2b       	or	r18, r19
 8b0:	24 2b       	or	r18, r20
 8b2:	25 2b       	or	r18, r21
 8b4:	21 f4       	brne	.+8      	; 0x8be <__fp_cmp+0x3e>
 8b6:	08 95       	ret
 8b8:	0a 26       	eor	r0, r26
 8ba:	09 f4       	brne	.+2      	; 0x8be <__fp_cmp+0x3e>
 8bc:	a1 40       	sbci	r26, 0x01	; 1
 8be:	a6 95       	lsr	r26
 8c0:	8f ef       	ldi	r24, 0xFF	; 255
 8c2:	81 1d       	adc	r24, r1
 8c4:	81 1d       	adc	r24, r1
 8c6:	08 95       	ret

000008c8 <__fp_split3>:
 8c8:	57 fd       	sbrc	r21, 7
 8ca:	90 58       	subi	r25, 0x80	; 128
 8cc:	44 0f       	add	r20, r20
 8ce:	55 1f       	adc	r21, r21
 8d0:	59 f0       	breq	.+22     	; 0x8e8 <__fp_splitA+0x10>
 8d2:	5f 3f       	cpi	r21, 0xFF	; 255
 8d4:	71 f0       	breq	.+28     	; 0x8f2 <__fp_splitA+0x1a>
 8d6:	47 95       	ror	r20

000008d8 <__fp_splitA>:
 8d8:	88 0f       	add	r24, r24
 8da:	97 fb       	bst	r25, 7
 8dc:	99 1f       	adc	r25, r25
 8de:	61 f0       	breq	.+24     	; 0x8f8 <__fp_splitA+0x20>
 8e0:	9f 3f       	cpi	r25, 0xFF	; 255
 8e2:	79 f0       	breq	.+30     	; 0x902 <__stack+0x3>
 8e4:	87 95       	ror	r24
 8e6:	08 95       	ret
 8e8:	12 16       	cp	r1, r18
 8ea:	13 06       	cpc	r1, r19
 8ec:	14 06       	cpc	r1, r20
 8ee:	55 1f       	adc	r21, r21
 8f0:	f2 cf       	rjmp	.-28     	; 0x8d6 <__fp_split3+0xe>
 8f2:	46 95       	lsr	r20
 8f4:	f1 df       	rcall	.-30     	; 0x8d8 <__fp_splitA>
 8f6:	08 c0       	rjmp	.+16     	; 0x908 <__stack+0x9>
 8f8:	16 16       	cp	r1, r22
 8fa:	17 06       	cpc	r1, r23
 8fc:	18 06       	cpc	r1, r24
 8fe:	99 1f       	adc	r25, r25
 900:	f1 cf       	rjmp	.-30     	; 0x8e4 <__fp_splitA+0xc>
 902:	86 95       	lsr	r24
 904:	71 05       	cpc	r23, r1
 906:	61 05       	cpc	r22, r1
 908:	08 94       	sec
 90a:	08 95       	ret

0000090c <__fp_zero>:
 90c:	e8 94       	clt

0000090e <__fp_szero>:
 90e:	bb 27       	eor	r27, r27
 910:	66 27       	eor	r22, r22
 912:	77 27       	eor	r23, r23
 914:	cb 01       	movw	r24, r22
 916:	97 f9       	bld	r25, 7
 918:	08 95       	ret

0000091a <__gesf2>:
 91a:	0e 94 40 04 	call	0x880	; 0x880 <__fp_cmp>
 91e:	08 f4       	brcc	.+2      	; 0x922 <__gesf2+0x8>
 920:	8f ef       	ldi	r24, 0xFF	; 255
 922:	08 95       	ret

00000924 <__mulsf3>:
 924:	0e 94 a5 04 	call	0x94a	; 0x94a <__mulsf3x>
 928:	0c 94 16 05 	jmp	0xa2c	; 0xa2c <__fp_round>
 92c:	0e 94 08 05 	call	0xa10	; 0xa10 <__fp_pscA>
 930:	38 f0       	brcs	.+14     	; 0x940 <__mulsf3+0x1c>
 932:	0e 94 0f 05 	call	0xa1e	; 0xa1e <__fp_pscB>
 936:	20 f0       	brcs	.+8      	; 0x940 <__mulsf3+0x1c>
 938:	95 23       	and	r25, r21
 93a:	11 f0       	breq	.+4      	; 0x940 <__mulsf3+0x1c>
 93c:	0c 94 ff 04 	jmp	0x9fe	; 0x9fe <__fp_inf>
 940:	0c 94 05 05 	jmp	0xa0a	; 0xa0a <__fp_nan>
 944:	11 24       	eor	r1, r1
 946:	0c 94 87 04 	jmp	0x90e	; 0x90e <__fp_szero>

0000094a <__mulsf3x>:
 94a:	0e 94 64 04 	call	0x8c8	; 0x8c8 <__fp_split3>
 94e:	70 f3       	brcs	.-36     	; 0x92c <__mulsf3+0x8>

00000950 <__mulsf3_pse>:
 950:	95 9f       	mul	r25, r21
 952:	c1 f3       	breq	.-16     	; 0x944 <__mulsf3+0x20>
 954:	95 0f       	add	r25, r21
 956:	50 e0       	ldi	r21, 0x00	; 0
 958:	55 1f       	adc	r21, r21
 95a:	62 9f       	mul	r22, r18
 95c:	f0 01       	movw	r30, r0
 95e:	72 9f       	mul	r23, r18
 960:	bb 27       	eor	r27, r27
 962:	f0 0d       	add	r31, r0
 964:	b1 1d       	adc	r27, r1
 966:	63 9f       	mul	r22, r19
 968:	aa 27       	eor	r26, r26
 96a:	f0 0d       	add	r31, r0
 96c:	b1 1d       	adc	r27, r1
 96e:	aa 1f       	adc	r26, r26
 970:	64 9f       	mul	r22, r20
 972:	66 27       	eor	r22, r22
 974:	b0 0d       	add	r27, r0
 976:	a1 1d       	adc	r26, r1
 978:	66 1f       	adc	r22, r22
 97a:	82 9f       	mul	r24, r18
 97c:	22 27       	eor	r18, r18
 97e:	b0 0d       	add	r27, r0
 980:	a1 1d       	adc	r26, r1
 982:	62 1f       	adc	r22, r18
 984:	73 9f       	mul	r23, r19
 986:	b0 0d       	add	r27, r0
 988:	a1 1d       	adc	r26, r1
 98a:	62 1f       	adc	r22, r18
 98c:	83 9f       	mul	r24, r19
 98e:	a0 0d       	add	r26, r0
 990:	61 1d       	adc	r22, r1
 992:	22 1f       	adc	r18, r18
 994:	74 9f       	mul	r23, r20
 996:	33 27       	eor	r19, r19
 998:	a0 0d       	add	r26, r0
 99a:	61 1d       	adc	r22, r1
 99c:	23 1f       	adc	r18, r19
 99e:	84 9f       	mul	r24, r20
 9a0:	60 0d       	add	r22, r0
 9a2:	21 1d       	adc	r18, r1
 9a4:	82 2f       	mov	r24, r18
 9a6:	76 2f       	mov	r23, r22
 9a8:	6a 2f       	mov	r22, r26
 9aa:	11 24       	eor	r1, r1
 9ac:	9f 57       	subi	r25, 0x7F	; 127
 9ae:	50 40       	sbci	r21, 0x00	; 0
 9b0:	9a f0       	brmi	.+38     	; 0x9d8 <__mulsf3_pse+0x88>
 9b2:	f1 f0       	breq	.+60     	; 0x9f0 <__mulsf3_pse+0xa0>
 9b4:	88 23       	and	r24, r24
 9b6:	4a f0       	brmi	.+18     	; 0x9ca <__mulsf3_pse+0x7a>
 9b8:	ee 0f       	add	r30, r30
 9ba:	ff 1f       	adc	r31, r31
 9bc:	bb 1f       	adc	r27, r27
 9be:	66 1f       	adc	r22, r22
 9c0:	77 1f       	adc	r23, r23
 9c2:	88 1f       	adc	r24, r24
 9c4:	91 50       	subi	r25, 0x01	; 1
 9c6:	50 40       	sbci	r21, 0x00	; 0
 9c8:	a9 f7       	brne	.-22     	; 0x9b4 <__mulsf3_pse+0x64>
 9ca:	9e 3f       	cpi	r25, 0xFE	; 254
 9cc:	51 05       	cpc	r21, r1
 9ce:	80 f0       	brcs	.+32     	; 0x9f0 <__mulsf3_pse+0xa0>
 9d0:	0c 94 ff 04 	jmp	0x9fe	; 0x9fe <__fp_inf>
 9d4:	0c 94 87 04 	jmp	0x90e	; 0x90e <__fp_szero>
 9d8:	5f 3f       	cpi	r21, 0xFF	; 255
 9da:	e4 f3       	brlt	.-8      	; 0x9d4 <__mulsf3_pse+0x84>
 9dc:	98 3e       	cpi	r25, 0xE8	; 232
 9de:	d4 f3       	brlt	.-12     	; 0x9d4 <__mulsf3_pse+0x84>
 9e0:	86 95       	lsr	r24
 9e2:	77 95       	ror	r23
 9e4:	67 95       	ror	r22
 9e6:	b7 95       	ror	r27
 9e8:	f7 95       	ror	r31
 9ea:	e7 95       	ror	r30
 9ec:	9f 5f       	subi	r25, 0xFF	; 255
 9ee:	c1 f7       	brne	.-16     	; 0x9e0 <__mulsf3_pse+0x90>
 9f0:	fe 2b       	or	r31, r30
 9f2:	88 0f       	add	r24, r24
 9f4:	91 1d       	adc	r25, r1
 9f6:	96 95       	lsr	r25
 9f8:	87 95       	ror	r24
 9fa:	97 f9       	bld	r25, 7
 9fc:	08 95       	ret

000009fe <__fp_inf>:
 9fe:	97 f9       	bld	r25, 7
 a00:	9f 67       	ori	r25, 0x7F	; 127
 a02:	80 e8       	ldi	r24, 0x80	; 128
 a04:	70 e0       	ldi	r23, 0x00	; 0
 a06:	60 e0       	ldi	r22, 0x00	; 0
 a08:	08 95       	ret

00000a0a <__fp_nan>:
 a0a:	9f ef       	ldi	r25, 0xFF	; 255
 a0c:	80 ec       	ldi	r24, 0xC0	; 192
 a0e:	08 95       	ret

00000a10 <__fp_pscA>:
 a10:	00 24       	eor	r0, r0
 a12:	0a 94       	dec	r0
 a14:	16 16       	cp	r1, r22
 a16:	17 06       	cpc	r1, r23
 a18:	18 06       	cpc	r1, r24
 a1a:	09 06       	cpc	r0, r25
 a1c:	08 95       	ret

00000a1e <__fp_pscB>:
 a1e:	00 24       	eor	r0, r0
 a20:	0a 94       	dec	r0
 a22:	12 16       	cp	r1, r18
 a24:	13 06       	cpc	r1, r19
 a26:	14 06       	cpc	r1, r20
 a28:	05 06       	cpc	r0, r21
 a2a:	08 95       	ret

00000a2c <__fp_round>:
 a2c:	09 2e       	mov	r0, r25
 a2e:	03 94       	inc	r0
 a30:	00 0c       	add	r0, r0
 a32:	11 f4       	brne	.+4      	; 0xa38 <__fp_round+0xc>
 a34:	88 23       	and	r24, r24
 a36:	52 f0       	brmi	.+20     	; 0xa4c <__fp_round+0x20>
 a38:	bb 0f       	add	r27, r27
 a3a:	40 f4       	brcc	.+16     	; 0xa4c <__fp_round+0x20>
 a3c:	bf 2b       	or	r27, r31
 a3e:	11 f4       	brne	.+4      	; 0xa44 <__fp_round+0x18>
 a40:	60 ff       	sbrs	r22, 0
 a42:	04 c0       	rjmp	.+8      	; 0xa4c <__fp_round+0x20>
 a44:	6f 5f       	subi	r22, 0xFF	; 255
 a46:	7f 4f       	sbci	r23, 0xFF	; 255
 a48:	8f 4f       	sbci	r24, 0xFF	; 255
 a4a:	9f 4f       	sbci	r25, 0xFF	; 255
 a4c:	08 95       	ret

00000a4e <_exit>:
 a4e:	f8 94       	cli

00000a50 <__stop_program>:
 a50:	ff cf       	rjmp	.-2      	; 0xa50 <__stop_program>
